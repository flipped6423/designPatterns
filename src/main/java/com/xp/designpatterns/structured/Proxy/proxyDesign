代理模式：即一个类代另外一个类完成这个类的功能，并可以在类前后插入一段逻辑，如打印日志，统计耗时

分类：
1.静态代理：适合需求简单且稳定的场景
2.动态代理：适合需要扩展和灵活性的复杂场景

静态代理：
在编译期由程序员手动编写代理类，代理类在编译时就已经存在，代理行为固定，无法在运行时改变

代理类和实现类实现相同的接口，然后通过代理类来调用实现类接口

优点：
1.实现简单，易于理解
2.可以在不修改目标类的情况下添加功能，符合开闭原则

缺点：
1.如果需要为多个目标类创建代理类，每个代理都需要重复编写相似的代码，造成代码冗余
2.若目标接口的功能或接口发送改变，代理类同步修改，扩展性差

应用场景：
1.日志记录
2.权限校验
3.性能监控

总：静态代理是一种简单且直观的的代理实现模式，适用于功能需求稳定、目标类数量较少的场景，
但由于扩展性较差，在复杂场景中使用动态代理替代

动态代理：
动态代理在运行时动态创建代理类并代理目标对象，动态代理一般基于接口（如JDK动态代理）或子类（如CGlib动态代理）

动态代理在不修改目标对象的情况下，为目标对象的方法动态的添加功能，如日志记录、权限校验、事务处理等

优点：
代理类在运行时生成，无需手动编写代理类，不需要在编译时定义，避免了手动创建代理类的繁琐，代码复用性高，代理行为可以灵活定义

缺点：
实现较为复杂，运行时性能低于静态代理

应用场景：
AOP(面向切面编程)：Spring中使用动态代理来实现事务管理、日志记录、权限控制等
远程调用：如RPC框架中代理远程服务
框架开发：动态代理应用与各种框架中，如Hibernate、mybatis等

动态代理和静态代理的区别：
静态代理是在编译期间就确定好代理关系，而动态代理时运行期间由JVM通过反射等技术生成的代理对象，不在.class中

动态代理实现的两种方式：
1.JDK中的动态代理，只能基于接口实现
2.CGLIB中的动态代理，可以基于接口和类实现

JDK怎么实现动态代理的？
1.定义接口
2.创建目标对象：目标对象即需要代理的实际业务逻辑的实现类
3.实现InvocationHandler接口
    Proxy类主要用来生成动态代理对象，而InvocationHandler接口则用来实现代理逻辑
    需要创建一个自定义的类，实现InvocationHandler接口，重写invoke方法，invoke方法复杂处理代理对象的所有方法调用，并在调用目标对象前后额外添加逻辑
4.生成代理对象
    使用Proxy.newProxyInstance()生成动态代理类的实例，会返回一个代理对象，该对象实现了目标对象的接口
5.通过代理对象调用方法

CGLIB是什么？
CGlib是一个高性能、强大的字节码生成库，用于在运行时动态生成类或增强类的功能。它可以通过字节码操作创建目标类的子类，从而实现方法拦截、代理等功能
CGlib通过继承目标类，生成目标类的子类，并在子类中重写目标类的方法。代理方法在调用时会转发到一个拦截器（MethodInterceptor）进行处理